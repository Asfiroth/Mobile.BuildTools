using System;
using System.IO;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Microsoft.Build.Utilities;
using Microsoft.Build.Tasks;

namespace Mobile.BuildTools.Generators
{
    public class SecretsClassGenerator
    {
        private const string AutoGeneratedMessage =
@"// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by Mobile.BuildTools.
//
//      Changes to this file may cause incorrect behavior and will be lost when 
//      the code is regenerated. 
//
//      This file should be excluded from source control.
//  </autogenerated>
// ------------------------------------------------------------------------------

";

        public string ProjectBasePath { get; set; }

        public string SecretsClassName { get; set; }

        public string SecretsJsonFilePath { get; set; }

        public string BaseNamespace { get; set; }

        public string OutputPath { get; set; }

        public TaskLoggingHelper Log { get; set; }

        public void Execute()
        {
            var json = File.ReadAllText(SecretsJsonFilePath);
            var secrets = JObject.Parse(json);
            var tabSpace = "    ";
            string replacement = string.Empty;

            foreach (var secret in secrets)
            {
                var value = secret.Value.ToString();
                if (bool.TryParse(value, out bool b))
                {
                    replacement += $"{tabSpace}{tabSpace}internal const bool {secret.Key} = {secret.Value};\n\n";
                }
                else if (double.TryParse(value, out double d))
                {
                    if (double.TryParse(secret.Value.ToString(), out double val))
                    {
                        var type = Regex.IsMatch(secret.Value.ToString(), @"^\d+$") ? "int" : "double";
                        replacement += $"{tabSpace}{tabSpace}internal const {type} {secret.Key} = {secret.Value};\n\n";
                    }
                    else
                    {
                        throw new NotSupportedException($"Unable to parse value for {secret.Key} - {secret.Value}");
                    }
                }
                else
                {
                    replacement += $"{tabSpace}{tabSpace}internal const string {secret.Key} = \"{secret.Value}\";\n\n";
                }
            }

            replacement = Regex.Replace(replacement, "\n\n$", "");

            var @namespace = GetNamespace();
            var secretsClass = $"{AutoGeneratedMessage}namespace {@namespace}\n{{\n{tabSpace}internal static class {SecretsClassName}\n{tabSpace}{{\n{replacement}\n{tabSpace}}}\n}}\n";
            Log.LogMessage(secretsClass);

            if (!Directory.Exists(OutputPath))
            {
                Directory.CreateDirectory(OutputPath);
            }

            File.WriteAllText(Path.Combine(OutputPath, $"{SecretsClassName}.cs"), secretsClass);
        }

        private string GetNamespace()
        {
            Uri file = new Uri(OutputPath);
            // Must end in a slash to indicate folder
            Uri folder = new Uri(ProjectBasePath);
            string relativePath =
            Uri.UnescapeDataString(
                folder.MakeRelativeUri(file)
                    .ToString()
                    .Replace('/', '.')
                );

            return relativePath;
        }
    }
}