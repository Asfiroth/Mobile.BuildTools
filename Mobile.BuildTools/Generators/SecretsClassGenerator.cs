using Microsoft.Build.Utilities;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace Mobile.BuildTools.Generators
{
    public class SecretsClassGenerator
    {
        private const string AutoGeneratedMessage =
@"// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by Mobile.BuildTools. For more information or to
//      file an issue please see https://github.com/dansiegel/Mobile.BuildTools
//
//      Changes to this file may cause incorrect behavior and will be lost when 
//      the code is regenerated. 
//
//      NOTE: This file should be excluded from source control.
//  </autogenerated>
// ------------------------------------------------------------------------------

";
        private const string TabSpace = "    ";

        public string ProjectBasePath { get; set; }

        public string SecretsClassName { get; set; }

        public string SecretsJsonFilePath { get; set; }

        public string BaseNamespace { get; set; }

        public string OutputPath { get; set; }

        public TaskLoggingHelper Log { get; set; }

        public void Execute()
        {
            var json = File.ReadAllText(SecretsJsonFilePath);
            var secrets = JObject.Parse(json);
            
            string replacement = string.Empty;

            foreach (var secret in secrets)
            {
                replacement += ProcessSecret(secret);
            }

            replacement = Regex.Replace(replacement, "\n\n$", "");

            var @namespace = GetNamespace();
            var secretsClass = $"{AutoGeneratedMessage}namespace {@namespace}\n{{\n{TabSpace}internal static class {SecretsClassName}\n{TabSpace}{{\n{replacement}\n{TabSpace}}}\n}}\n";
            Log.LogMessage(secretsClass);

            if (!Directory.Exists(OutputPath))
            {
                Directory.CreateDirectory(OutputPath);
            }

            File.WriteAllText(Path.Combine(OutputPath, $"{SecretsClassName}.cs"), secretsClass);
        }

        internal string ProcessSecret(KeyValuePair<string, JToken> secret)
        {
            var value = secret.Value.ToString();
            if (bool.TryParse(value, out bool b))
            {
                return $"{TabSpace}{TabSpace}internal const bool {secret.Key} = {secret.Value};\n\n";
            }
            else if (double.TryParse(value, out double d))
            {
                if (double.TryParse(secret.Value.ToString(), out double val))
                {
                    var type = Regex.IsMatch(secret.Value.ToString(), @"^\d+$") ? "int" : "double";
                    return $"{TabSpace}{TabSpace}internal const {type} {secret.Key} = {secret.Value};\n\n";
                }
                else
                {
                    throw new NotSupportedException($"Unable to parse value for {secret.Key} - {secret.Value}");
                }
            }
            else
            {
                return $"{TabSpace}{TabSpace}internal const string {secret.Key} = \"{secret.Value}\";\n\n";
            }
        }

        private string GetNamespace()
        {
            Uri file = new Uri(OutputPath);
            // Must end in a slash to indicate folder
            Uri folder = new Uri(ProjectBasePath);
            string relativePath =
            Uri.UnescapeDataString(
                folder.MakeRelativeUri(file)
                    .ToString()
                    .Replace('/', '.')
                );

            return relativePath;
        }
    }
}