using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Json;
using Microsoft.Build.Utilities;

namespace Mobile.BuildTools.Generators
{
    public class SecretsClassGenerator
    {
        private const string AutoGeneratedMessage = 
@"// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a Mobile.BuildTools.
// 
//      Changes to this file may cause incorrect behavior and will be lost when 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

";

        public string ProjectBasePath { get; set; }

        public string SecretsClassName { get; set; }

        public string SecretsJsonFilePath { get; set; }

        public string BaseNamespace { get; set; }

        public string OutputPath { get; set; }

        public TaskLoggingHelper Log { get; set; }

        public void Execute()
        {
            var json = File.ReadAllText(SecretsJsonFilePath);
            var secrets = JsonValue.Parse(json) as JsonObject;
            var tabSpace = "    ";
            string replacement = string.Empty;

            foreach (var secret in secrets)
            {
                switch(secret.Value.JsonType)
                {
                    case JsonType.Boolean:
                        replacement += $"{tabSpace}{tabSpace}internal const bool {secret.Key} = {secret.Value};\n\n";
                        break;
                    case JsonType.Number:
                        if(double.TryParse(secret.Value.ToString(), out double val))
                        {
                            var type = Regex.IsMatch(secret.Value.ToString(), @"^\d+$") ? "int" : "double";
                            replacement += $"{tabSpace}{tabSpace}internal const {type} {secret.Key} = {secret.Value};\n\n";
                        }
                        else
                        {
                            throw new NotSupportedException($"Unable to parse value for {secret.Key} - {secret.Value}");
                        }
                        break;
                    case JsonType.String:
                        replacement += $"{tabSpace}{tabSpace}internal const string {secret.Key} = {secret.Value};\n\n";
                        break;
                    default:
                        throw new NotSupportedException($"Secret {secret.Key} does not support Json Type {secret.Value.JsonType}");
                }
            }

            replacement = Regex.Replace(replacement, "\n\n$", "");

            var @namespace = GetNamespace();
            var secretsClass = $"{AutoGeneratedMessage}namespace {@namespace}\n{{\n{tabSpace}internal static class {SecretsClassName}\n{tabSpace}{{\n{replacement}\n{tabSpace}}}\n}}\n";
            Log.LogMessage(secretsClass);

            File.WriteAllText(Path.Combine(OutputPath, $"{SecretsClassName}.cs"), secretsClass);
        }

        private string GetNamespace()
        {
            Uri file = new Uri(OutputPath);
            // Must end in a slash to indicate folder
            Uri folder = new Uri(ProjectBasePath);
            string relativePath =
            Uri.UnescapeDataString(
                folder.MakeRelativeUri(file)
                    .ToString()
                    .Replace('/', '.')
                );

            return relativePath;
        }
    }
}