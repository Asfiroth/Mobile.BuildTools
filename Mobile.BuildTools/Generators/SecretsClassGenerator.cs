using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using Mobile.BuildTools.Logging;
using Newtonsoft.Json.Linq;

namespace Mobile.BuildTools.Generators
{
    public class SecretsClassGenerator : IGenerator
    {
        private const string AutoGeneratedMessage =
@"// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by Mobile.BuildTools. For more information or to
//      file an issue please see https://github.com/dansiegel/Mobile.BuildTools
//
//      Changes to this file may cause incorrect behavior and will be lost when 
//      the code is regenerated. 
//
//      NOTE: This file should be excluded from source control.
//  </autogenerated>
// ------------------------------------------------------------------------------

";

        private const string SafePlaceholder = "*****";

        private const string TabSpace = "    ";

        public string ProjectBasePath { get; set; }

        public string SecretsClassName { get; set; }

        public string SecretsJsonFilePath { get; set; }

        public string BaseNamespace { get; set; }

        public string OutputPath { get; set; }

        public string IntermediateOutputPath { get; set; }

        public bool? DebugOutput { get; set; }

        public ILog Log { get; set; }

        public ITaskItem[] GeneratedFiles { get; private set; }

        public void Execute()
        {
            if (DebugOutput == null)
            {
                DebugOutput = false;
            }

            var json = File.ReadAllText(SecretsJsonFilePath);
            var secrets = JObject.Parse(json);

            var replacement = string.Empty;
            var safeReplacement = string.Empty;

            foreach (var secret in secrets)
            {
                replacement += ProcessSecret(secret);
                safeReplacement += ProcessSecret(secret, true);
            }

            replacement = Regex.Replace(replacement, "\n\n$", "");

            var secretsClass = GenerateClass(replacement);
            Log.LogMessage((bool)DebugOutput ? secretsClass : GenerateClass(Regex.Replace(safeReplacement, "\n\n$", "")));

            var projectFile = Path.Combine(OutputPath, $"{SecretsClassName}.cs");
            var intermediateFile = Path.Combine(IntermediateOutputPath, $"{SecretsClassName}.cs");
            var outputFile = File.Exists(projectFile) ? projectFile : intermediateFile;
            Log.LogMessage($"Writing Secrets Class to: '{outputFile}'");
            GeneratedFiles = new ITaskItem[] {
                new TaskItem(ProjectCollection.Escape(outputFile))
            };

            File.WriteAllText(outputFile, secretsClass);
        }

        internal string GenerateClass(string replacement) =>
            $"{AutoGeneratedMessage}namespace {GetNamespace()}\n{{\n{TabSpace}internal static class {SecretsClassName}\n{TabSpace}{{\n{replacement}\n{TabSpace}}}\n}}\n";

        internal string ProcessSecret(KeyValuePair<string, JToken> secret, bool safeOutput = false)
        {
            var value = secret.Value.ToString();
            var outputValue = safeOutput ? SafePlaceholder : value;
            if (bool.TryParse(value, out var b))
            {
                return $"{TabSpace}{TabSpace}internal const bool {secret.Key} = {outputValue.ToLower()};\n\n";
            }
            else if (Regex.IsMatch(value, @"\d+\.\d+") && double.TryParse(value, out var d))
            {
                return $"{TabSpace}{TabSpace}internal const double {secret.Key} = {outputValue};\n\n";
            }
            else if (int.TryParse(value, out var i))
            {
                return $"{TabSpace}{TabSpace}internal const int {secret.Key} = {outputValue};\n\n";
            }
            else
            {
                return $"{TabSpace}{TabSpace}internal const string {secret.Key} = \"{outputValue}\";\n\n";
            }
        }

        internal string GetNamespace()
        {
            var file = new Uri(OutputPath);
            // Must end in a slash to indicate folder
            var folder = new Uri(ProjectBasePath);
            var relativePath =
            Uri.UnescapeDataString(
                folder.MakeRelativeUri(file)
                      .ToString()
                      .Replace('/', '.')
                );

            if(!string.IsNullOrWhiteSpace(BaseNamespace))
            {
                var folderName = Path.GetFileName(ProjectBasePath);
                relativePath = Regex.Replace(relativePath, folderName, BaseNamespace);
            }
            else
            {
                Log.LogWarning($"Using Fallback namespace: {relativePath}");
            }

            return relativePath;
        }
    }
}