using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using Mobile.BuildTools.Build;
using Mobile.BuildTools.Models.Secrets;
using Mobile.BuildTools.Utils;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Mobile.BuildTools.Generators.Secrets
{
    internal class SecretsClassGenerator : GeneratorBase
    {
#pragma warning disable IDE1006, IDE0040
        private const string AutoGeneratedMessage =
@"// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by Mobile.BuildTools. For more information or to
//      file an issue please see https://github.com/dansiegel/Mobile.BuildTools
//
//      Changes to this file may cause incorrect behavior and will be lost when 
//      the code is regenerated.
//
//      When I wrote this, only God and I understood what I was doing
//      Now, God only knows.
//
//      NOTE: This file should be excluded from source control.
//  </autogenerated>
// ------------------------------------------------------------------------------

";

        private const string SafePlaceholder = "*****";

        private const string TabSpace = "    ";

        private static readonly IReadOnlyDictionary<PropertyType, string> PropertyTypeMappings = new Dictionary<PropertyType, string>
        {
            { PropertyType.Bool, "{0}" },
            { PropertyType.DateTime, "DateTime.Parse(\"{0}\")" }
        };

        public SecretsClassGenerator(IBuildConfiguration buildConfiguration)
            : base(buildConfiguration)
        {
        }
#pragma warning restore IDE1006, IDE0040

        public string SecretsClassName { get; set; }

        public string ConfigurationSecretsJsonFilePath { get; set; }

        public string SecretsJsonFilePath { get; set; }

        public string BaseNamespace { get; set; }

        public string OutputPath { get; set; }

        public ITaskItem[] GeneratedFiles { get; private set; }

        protected override void Execute()
        {
            var secrets = GetMergedSecrets();

            var replacement = string.Empty;
            var safeReplacement = string.Empty;
            var secretsConfig = LoadConfig();
            bool saveConfig = secretsConfig is null;
            if(saveConfig)
            {
                secretsConfig = new SecretsConfig()
                {
                    Delimiter = ";"
                };
            }

            foreach (var secret in secrets)
            {
                replacement += ProcessSecret(secret, secretsConfig, saveConfig);
                safeReplacement += ProcessSecret(secret, secretsConfig, false, true);
            }

            if(Build.Configuration.ProjectSecrets is null)
            {
                Build.Configuration.ProjectSecrets = new Dictionary<string, SecretsConfig>();
            }
            Build.Configuration.ProjectSecrets.Add(Build.GlobalProperties["ProjectName"], secretsConfig);
            Build.SaveConfiguration();

            replacement = Regex.Replace(replacement, "\n\n$", "");

            var secretsClass = GenerateClass(replacement);
            Log.LogMessage(Build.Configuration.Debug ? secretsClass : GenerateClass(Regex.Replace(safeReplacement, "\n\n$", "")));

            var projectFile = Path.Combine(OutputPath, $"{SecretsClassName}.cs");
            var intermediateFile = Path.Combine(Build.IntermediateOutputPath, $"{SecretsClassName}.cs");
            var outputFile = File.Exists(projectFile) ? projectFile : intermediateFile;
            Log.LogMessage($"Writing Secrets Class to: '{outputFile}'");
            GeneratedFiles = new ITaskItem[] {
                new TaskItem(ProjectCollection.Escape(outputFile))
            };

            File.WriteAllText(outputFile, secretsClass);
        }

        internal JObject GetMergedSecrets()
        {
            JObject secrets = null;
            CreateOrMerge(SecretsJsonFilePath, ref secrets);
            CreateOrMerge(ConfigurationSecretsJsonFilePath, ref secrets);

            if(secrets is null)
            {
                throw new Exception("An unexpected error occurred. Could not locate any secrets.");
            }

            return secrets;
        }

        internal void CreateOrMerge(string jsonFilePath, ref JObject secrets)
        {
            if(File.Exists(jsonFilePath))
            {
                var json = File.ReadAllText(jsonFilePath);
                if(secrets is null)
                {
                    secrets = JObject.Parse(json);
                }
                else
                {
                    foreach(var pair in secrets)
                    {
                        secrets[pair.Key] = pair.Value;
                    }
                }
            }
        }

        internal string GenerateClass(string replacement) =>
            $"{AutoGeneratedMessage}\n\nusing System;\n\nnamespace {GetNamespace()}\n{{\n{TabSpace}internal static class {SecretsClassName}\n{TabSpace}{{\n{replacement}\n{TabSpace}}}\n}}\n";

        internal string ProcessSecret(KeyValuePair<string, JToken> secret, SecretsConfig secretsConfig, bool saveOutput, bool safeOutput = false)
        {
            var valueConfig = secretsConfig.ContainsKey(secret.Key) ? secretsConfig[secret.Key] : null;
            if (!saveOutput && valueConfig is null)
            {
                return null;
            }

            if(valueConfig is null)
            {
                valueConfig = GenerateValueConfig(secret.Value, secretsConfig);
                secretsConfig.Add(secret.Key, valueConfig);
            }

            var mapping = valueConfig.PropertyType.GetPropertyTypeMapping();
            return PropertyBuilder(secret, mapping.Type, mapping.Format, valueConfig.IsArray, safeOutput);
        }

        internal ValueConfig GenerateValueConfig(JToken token, SecretsConfig config)
        {
            var value = token.ToString();
            var valueArray = Regex.Split(value, $"(?<!\\\\){config.Delimiter}").Select(x => x.Replace($"\\{config.Delimiter}", config.Delimiter));
            bool isArray = false;
            if (valueArray.Count() > 1)
            {
                value = valueArray.FirstOrDefault();
            }
            var type = PropertyType.String;

            if(bool.TryParse(value, out _))
            {
                type = PropertyType.Bool;
            }
            else if (Regex.IsMatch(value, @"\d+\.\d+") && double.TryParse(value, out _))
            {
                type = PropertyType.Double;
            }
            else if (int.TryParse(value, out _))
            {
                type = PropertyType.Int;
            }

            return new ValueConfig { IsArray = isArray, PropertyType = type };
        }

        internal string GetNamespace()
        {
            var file = new Uri(OutputPath);
            // Must end in a slash to indicate folder
            var folder = new Uri(Build.ProjectDirectory);
            var relativePath =
            Uri.UnescapeDataString(
                folder.MakeRelativeUri(file)
                      .ToString()
                      .Replace('/', '.')
                );

            if(!string.IsNullOrWhiteSpace(BaseNamespace))
            {
                var folderName = Path.GetFileName(Build.ProjectDirectory);
                relativePath = Regex.Replace(relativePath, folderName, BaseNamespace);
            }
            else
            {
                Log.LogWarning($"Using Fallback namespace: {relativePath}");
            }

            return relativePath;
        }

        internal string PropertyBuilder(KeyValuePair<string, JToken> secret, Type type, string propertyFormat, bool isArray, bool safeOutput)
        {
            var accessModifier = type.IsPrimitive ? "const" : "static readonly";
            var output = string.Empty;
            var typeDeclaration = type.GetStandardTypeName();
            if(isArray)
            {
                typeDeclaration += "[]";
                var valueArray = GetValueArray(secret.Value).Select(x => string.Format(propertyFormat, GetOutputValue(x, safeOutput)));
                output = "new[] { " + string.Join(", ", valueArray) + " }";
            }
            else
            {
                output = string.Format(propertyFormat, GetOutputValue(secret.Value, safeOutput));
            }

            if(type == typeof(bool))
            {
                output = output.ToLower();
            }

            return $"{TabSpace}{TabSpace}internal {accessModifier} {typeDeclaration} {secret.Key} = {output};\n\n";
        }

        internal static IEnumerable<string> GetValueArray(JToken token) =>
            Regex.Split(token.ToString(), "(?<!\\\\);").Select(x => x.Replace("\\;", ";"));

        private string GetOutputValue(JToken value, bool safeOutput) =>
            GetOutputValue(value.ToString(), safeOutput);

        private string GetOutputValue(string value, bool safeOutput) =>
            safeOutput ? SafePlaceholder : value.ToString();

        internal SecretsConfig LoadConfig()
        {
            var configPath = Path.Combine(Build.ProjectDirectory, "secrets.config");
            if(File.Exists(configPath))
            {
                return JsonConvert.DeserializeObject<SecretsConfig>(configPath);
            }

            return Build.Configuration.ProjectSecrets.FirstOrDefault(x => x.Key == Build.GlobalProperties["ProjectName"]).Value;
        }
    }
}